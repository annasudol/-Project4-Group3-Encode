{"ast":null,"code":"\"use strict\";\n\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n  // Find the first error (if any)\n  const errors = [];\n\n  const checkErrors = function (path, object) {\n    if (!Array.isArray(object)) {\n      return;\n    }\n\n    for (let key in object) {\n      const childPath = path.slice();\n      childPath.push(key);\n\n      try {\n        checkErrors(childPath, object[key]);\n      } catch (error) {\n        errors.push({\n          path: childPath,\n          error: error\n        });\n      }\n    }\n  };\n\n  checkErrors([], result);\n  return errors;\n}\nexport class Coder {\n  constructor(name, type, localName, dynamic) {\n    // @TODO: defineReadOnly these\n    this.name = name;\n    this.type = type;\n    this.localName = localName;\n    this.dynamic = dynamic;\n  }\n\n  _throwError(message, value) {\n    logger.throwArgumentError(message, this.localName, value);\n  }\n\n}\nexport class Writer {\n  constructor(wordSize) {\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    this._data = [];\n    this._dataLength = 0;\n    this._padding = new Uint8Array(wordSize);\n  }\n\n  get data() {\n    return hexConcat(this._data);\n  }\n\n  get length() {\n    return this._dataLength;\n  }\n\n  _writeData(data) {\n    this._data.push(data);\n\n    this._dataLength += data.length;\n    return data.length;\n  }\n\n  appendWriter(writer) {\n    return this._writeData(concat(writer._data));\n  } // Arrayish items; padded on the right to wordSize\n\n\n  writeBytes(value) {\n    let bytes = arrayify(value);\n    const paddingOffset = bytes.length % this.wordSize;\n\n    if (paddingOffset) {\n      bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n    }\n\n    return this._writeData(bytes);\n  }\n\n  _getValue(value) {\n    let bytes = arrayify(BigNumber.from(value));\n\n    if (bytes.length > this.wordSize) {\n      logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n        length: this.wordSize,\n        offset: bytes.length\n      });\n    }\n\n    if (bytes.length % this.wordSize) {\n      bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n    }\n\n    return bytes;\n  } // BigNumberish items; padded on the left to wordSize\n\n\n  writeValue(value) {\n    return this._writeData(this._getValue(value));\n  }\n\n  writeUpdatableValue() {\n    const offset = this._data.length;\n\n    this._data.push(this._padding);\n\n    this._dataLength += this.wordSize;\n    return value => {\n      this._data[offset] = this._getValue(value);\n    };\n  }\n\n}\nexport class Reader {\n  constructor(data, wordSize, coerceFunc, allowLoose) {\n    defineReadOnly(this, \"_data\", arrayify(data));\n    defineReadOnly(this, \"wordSize\", wordSize || 32);\n    defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n    defineReadOnly(this, \"allowLoose\", allowLoose);\n    this._offset = 0;\n  }\n\n  get data() {\n    return hexlify(this._data);\n  }\n\n  get consumed() {\n    return this._offset;\n  } // The default Coerce function\n\n\n  static coerce(name, value) {\n    let match = name.match(\"^u?int([0-9]+)$\");\n\n    if (match && parseInt(match[1]) <= 48) {\n      value = value.toNumber();\n    }\n\n    return value;\n  }\n\n  coerce(name, value) {\n    if (this._coerceFunc) {\n      return this._coerceFunc(name, value);\n    }\n\n    return Reader.coerce(name, value);\n  }\n\n  _peekBytes(offset, length, loose) {\n    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\n    if (this._offset + alignedLength > this._data.length) {\n      if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n        alignedLength = length;\n      } else {\n        logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n          length: this._data.length,\n          offset: this._offset + alignedLength\n        });\n      }\n    }\n\n    return this._data.slice(this._offset, this._offset + alignedLength);\n  }\n\n  subReader(offset) {\n    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n  }\n\n  readBytes(length, loose) {\n    let bytes = this._peekBytes(0, length, !!loose);\n\n    this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?\n\n    return bytes.slice(0, length);\n  }\n\n  readValue() {\n    return BigNumber.from(this.readBytes(this.wordSize));\n  }\n\n}","map":{"version":3,"names":["arrayify","concat","hexConcat","hexlify","BigNumber","defineReadOnly","Logger","version","logger","checkResultErrors","result","errors","checkErrors","path","object","Array","isArray","key","childPath","slice","push","error","Coder","constructor","name","type","localName","dynamic","_throwError","message","value","throwArgumentError","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","data","length","_writeData","appendWriter","writer","writeBytes","bytes","paddingOffset","_getValue","from","throwError","BUFFER_OVERRUN","offset","writeValue","writeUpdatableValue","Reader","coerceFunc","allowLoose","_offset","consumed","coerce","match","parseInt","toNumber","_coerceFunc","_peekBytes","loose","alignedLength","Math","ceil","subReader","readBytes","readValue"],"sources":["/Users/annasudol/Documents/encode/Project4-Group3-Encode/frontend/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js"],"sourcesContent":["\"use strict\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n"],"mappings":"AAAA;;AACA,SAASA,QAAT,EAAmBC,MAAnB,EAA2BC,SAA3B,EAAsCC,OAAtC,QAAqD,sBAArD;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,cAAT,QAA+B,2BAA/B;AACA,SAASC,MAAT,QAAuB,uBAAvB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAWC,OAAX,CAAf;AACA,OAAO,SAASE,iBAAT,CAA2BC,MAA3B,EAAmC;EACtC;EACA,MAAMC,MAAM,GAAG,EAAf;;EACA,MAAMC,WAAW,GAAG,UAAUC,IAAV,EAAgBC,MAAhB,EAAwB;IACxC,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcF,MAAd,CAAL,EAA4B;MACxB;IACH;;IACD,KAAK,IAAIG,GAAT,IAAgBH,MAAhB,EAAwB;MACpB,MAAMI,SAAS,GAAGL,IAAI,CAACM,KAAL,EAAlB;MACAD,SAAS,CAACE,IAAV,CAAeH,GAAf;;MACA,IAAI;QACAL,WAAW,CAACM,SAAD,EAAYJ,MAAM,CAACG,GAAD,CAAlB,CAAX;MACH,CAFD,CAGA,OAAOI,KAAP,EAAc;QACVV,MAAM,CAACS,IAAP,CAAY;UAAEP,IAAI,EAAEK,SAAR;UAAmBG,KAAK,EAAEA;QAA1B,CAAZ;MACH;IACJ;EACJ,CAdD;;EAeAT,WAAW,CAAC,EAAD,EAAKF,MAAL,CAAX;EACA,OAAOC,MAAP;AACH;AACD,OAAO,MAAMW,KAAN,CAAY;EACfC,WAAW,CAACC,IAAD,EAAOC,IAAP,EAAaC,SAAb,EAAwBC,OAAxB,EAAiC;IACxC;IACA,KAAKH,IAAL,GAAYA,IAAZ;IACA,KAAKC,IAAL,GAAYA,IAAZ;IACA,KAAKC,SAAL,GAAiBA,SAAjB;IACA,KAAKC,OAAL,GAAeA,OAAf;EACH;;EACDC,WAAW,CAACC,OAAD,EAAUC,KAAV,EAAiB;IACxBtB,MAAM,CAACuB,kBAAP,CAA0BF,OAA1B,EAAmC,KAAKH,SAAxC,EAAmDI,KAAnD;EACH;;AAVc;AAYnB,OAAO,MAAME,MAAN,CAAa;EAChBT,WAAW,CAACU,QAAD,EAAW;IAClB5B,cAAc,CAAC,IAAD,EAAO,UAAP,EAAmB4B,QAAQ,IAAI,EAA/B,CAAd;IACA,KAAKC,KAAL,GAAa,EAAb;IACA,KAAKC,WAAL,GAAmB,CAAnB;IACA,KAAKC,QAAL,GAAgB,IAAIC,UAAJ,CAAeJ,QAAf,CAAhB;EACH;;EACO,IAAJK,IAAI,GAAG;IACP,OAAOpC,SAAS,CAAC,KAAKgC,KAAN,CAAhB;EACH;;EACS,IAANK,MAAM,GAAG;IAAE,OAAO,KAAKJ,WAAZ;EAA0B;;EACzCK,UAAU,CAACF,IAAD,EAAO;IACb,KAAKJ,KAAL,CAAWd,IAAX,CAAgBkB,IAAhB;;IACA,KAAKH,WAAL,IAAoBG,IAAI,CAACC,MAAzB;IACA,OAAOD,IAAI,CAACC,MAAZ;EACH;;EACDE,YAAY,CAACC,MAAD,EAAS;IACjB,OAAO,KAAKF,UAAL,CAAgBvC,MAAM,CAACyC,MAAM,CAACR,KAAR,CAAtB,CAAP;EACH,CAlBe,CAmBhB;;;EACAS,UAAU,CAACb,KAAD,EAAQ;IACd,IAAIc,KAAK,GAAG5C,QAAQ,CAAC8B,KAAD,CAApB;IACA,MAAMe,aAAa,GAAGD,KAAK,CAACL,MAAN,GAAe,KAAKN,QAA1C;;IACA,IAAIY,aAAJ,EAAmB;MACfD,KAAK,GAAG3C,MAAM,CAAC,CAAC2C,KAAD,EAAQ,KAAKR,QAAL,CAAcjB,KAAd,CAAoB0B,aAApB,CAAR,CAAD,CAAd;IACH;;IACD,OAAO,KAAKL,UAAL,CAAgBI,KAAhB,CAAP;EACH;;EACDE,SAAS,CAAChB,KAAD,EAAQ;IACb,IAAIc,KAAK,GAAG5C,QAAQ,CAACI,SAAS,CAAC2C,IAAV,CAAejB,KAAf,CAAD,CAApB;;IACA,IAAIc,KAAK,CAACL,MAAN,GAAe,KAAKN,QAAxB,EAAkC;MAC9BzB,MAAM,CAACwC,UAAP,CAAkB,qBAAlB,EAAyC1C,MAAM,CAACK,MAAP,CAAcsC,cAAvD,EAAuE;QACnEV,MAAM,EAAE,KAAKN,QADsD;QAEnEiB,MAAM,EAAEN,KAAK,CAACL;MAFqD,CAAvE;IAIH;;IACD,IAAIK,KAAK,CAACL,MAAN,GAAe,KAAKN,QAAxB,EAAkC;MAC9BW,KAAK,GAAG3C,MAAM,CAAC,CAAC,KAAKmC,QAAL,CAAcjB,KAAd,CAAoByB,KAAK,CAACL,MAAN,GAAe,KAAKN,QAAxC,CAAD,EAAoDW,KAApD,CAAD,CAAd;IACH;;IACD,OAAOA,KAAP;EACH,CAxCe,CAyChB;;;EACAO,UAAU,CAACrB,KAAD,EAAQ;IACd,OAAO,KAAKU,UAAL,CAAgB,KAAKM,SAAL,CAAehB,KAAf,CAAhB,CAAP;EACH;;EACDsB,mBAAmB,GAAG;IAClB,MAAMF,MAAM,GAAG,KAAKhB,KAAL,CAAWK,MAA1B;;IACA,KAAKL,KAAL,CAAWd,IAAX,CAAgB,KAAKgB,QAArB;;IACA,KAAKD,WAAL,IAAoB,KAAKF,QAAzB;IACA,OAAQH,KAAD,IAAW;MACd,KAAKI,KAAL,CAAWgB,MAAX,IAAqB,KAAKJ,SAAL,CAAehB,KAAf,CAArB;IACH,CAFD;EAGH;;AApDe;AAsDpB,OAAO,MAAMuB,MAAN,CAAa;EAChB9B,WAAW,CAACe,IAAD,EAAOL,QAAP,EAAiBqB,UAAjB,EAA6BC,UAA7B,EAAyC;IAChDlD,cAAc,CAAC,IAAD,EAAO,OAAP,EAAgBL,QAAQ,CAACsC,IAAD,CAAxB,CAAd;IACAjC,cAAc,CAAC,IAAD,EAAO,UAAP,EAAmB4B,QAAQ,IAAI,EAA/B,CAAd;IACA5B,cAAc,CAAC,IAAD,EAAO,aAAP,EAAsBiD,UAAtB,CAAd;IACAjD,cAAc,CAAC,IAAD,EAAO,YAAP,EAAqBkD,UAArB,CAAd;IACA,KAAKC,OAAL,GAAe,CAAf;EACH;;EACO,IAAJlB,IAAI,GAAG;IAAE,OAAOnC,OAAO,CAAC,KAAK+B,KAAN,CAAd;EAA6B;;EAC9B,IAARuB,QAAQ,GAAG;IAAE,OAAO,KAAKD,OAAZ;EAAsB,CATvB,CAUhB;;;EACa,OAANE,MAAM,CAAClC,IAAD,EAAOM,KAAP,EAAc;IACvB,IAAI6B,KAAK,GAAGnC,IAAI,CAACmC,KAAL,CAAW,iBAAX,CAAZ;;IACA,IAAIA,KAAK,IAAIC,QAAQ,CAACD,KAAK,CAAC,CAAD,CAAN,CAAR,IAAsB,EAAnC,EAAuC;MACnC7B,KAAK,GAAGA,KAAK,CAAC+B,QAAN,EAAR;IACH;;IACD,OAAO/B,KAAP;EACH;;EACD4B,MAAM,CAAClC,IAAD,EAAOM,KAAP,EAAc;IAChB,IAAI,KAAKgC,WAAT,EAAsB;MAClB,OAAO,KAAKA,WAAL,CAAiBtC,IAAjB,EAAuBM,KAAvB,CAAP;IACH;;IACD,OAAOuB,MAAM,CAACK,MAAP,CAAclC,IAAd,EAAoBM,KAApB,CAAP;EACH;;EACDiC,UAAU,CAACb,MAAD,EAASX,MAAT,EAAiByB,KAAjB,EAAwB;IAC9B,IAAIC,aAAa,GAAGC,IAAI,CAACC,IAAL,CAAU5B,MAAM,GAAG,KAAKN,QAAxB,IAAoC,KAAKA,QAA7D;;IACA,IAAI,KAAKuB,OAAL,GAAeS,aAAf,GAA+B,KAAK/B,KAAL,CAAWK,MAA9C,EAAsD;MAClD,IAAI,KAAKgB,UAAL,IAAmBS,KAAnB,IAA4B,KAAKR,OAAL,GAAejB,MAAf,IAAyB,KAAKL,KAAL,CAAWK,MAApE,EAA4E;QACxE0B,aAAa,GAAG1B,MAAhB;MACH,CAFD,MAGK;QACD/B,MAAM,CAACwC,UAAP,CAAkB,oBAAlB,EAAwC1C,MAAM,CAACK,MAAP,CAAcsC,cAAtD,EAAsE;UAClEV,MAAM,EAAE,KAAKL,KAAL,CAAWK,MAD+C;UAElEW,MAAM,EAAE,KAAKM,OAAL,GAAeS;QAF2C,CAAtE;MAIH;IACJ;;IACD,OAAO,KAAK/B,KAAL,CAAWf,KAAX,CAAiB,KAAKqC,OAAtB,EAA+B,KAAKA,OAAL,GAAeS,aAA9C,CAAP;EACH;;EACDG,SAAS,CAAClB,MAAD,EAAS;IACd,OAAO,IAAIG,MAAJ,CAAW,KAAKnB,KAAL,CAAWf,KAAX,CAAiB,KAAKqC,OAAL,GAAeN,MAAhC,CAAX,EAAoD,KAAKjB,QAAzD,EAAmE,KAAK6B,WAAxE,EAAqF,KAAKP,UAA1F,CAAP;EACH;;EACDc,SAAS,CAAC9B,MAAD,EAASyB,KAAT,EAAgB;IACrB,IAAIpB,KAAK,GAAG,KAAKmB,UAAL,CAAgB,CAAhB,EAAmBxB,MAAnB,EAA2B,CAAC,CAACyB,KAA7B,CAAZ;;IACA,KAAKR,OAAL,IAAgBZ,KAAK,CAACL,MAAtB,CAFqB,CAGrB;;IACA,OAAOK,KAAK,CAACzB,KAAN,CAAY,CAAZ,EAAeoB,MAAf,CAAP;EACH;;EACD+B,SAAS,GAAG;IACR,OAAOlE,SAAS,CAAC2C,IAAV,CAAe,KAAKsB,SAAL,CAAe,KAAKpC,QAApB,CAAf,CAAP;EACH;;AAlDe"},"metadata":{},"sourceType":"module"}