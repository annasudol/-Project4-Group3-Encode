{"ast":null,"code":"\"use strict\"; //See: https://github.com/ethereum/wiki/wiki/RLP\n\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction arrayifyInteger(value) {\n  const result = [];\n\n  while (value) {\n    result.unshift(value & 0xff);\n    value >>= 8;\n  }\n\n  return result;\n}\n\nfunction unarrayifyInteger(data, offset, length) {\n  let result = 0;\n\n  for (let i = 0; i < length; i++) {\n    result = result * 256 + data[offset + i];\n  }\n\n  return result;\n}\n\nfunction _encode(object) {\n  if (Array.isArray(object)) {\n    let payload = [];\n    object.forEach(function (child) {\n      payload = payload.concat(_encode(child));\n    });\n\n    if (payload.length <= 55) {\n      payload.unshift(0xc0 + payload.length);\n      return payload;\n    }\n\n    const length = arrayifyInteger(payload.length);\n    length.unshift(0xf7 + length.length);\n    return length.concat(payload);\n  }\n\n  if (!isBytesLike(object)) {\n    logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n  }\n\n  const data = Array.prototype.slice.call(arrayify(object));\n\n  if (data.length === 1 && data[0] <= 0x7f) {\n    return data;\n  } else if (data.length <= 55) {\n    data.unshift(0x80 + data.length);\n    return data;\n  }\n\n  const length = arrayifyInteger(data.length);\n  length.unshift(0xb7 + length.length);\n  return length.concat(data);\n}\n\nexport function encode(object) {\n  return hexlify(_encode(object));\n}\n\nfunction _decodeChildren(data, offset, childOffset, length) {\n  const result = [];\n\n  while (childOffset < offset + 1 + length) {\n    const decoded = _decode(data, childOffset);\n\n    result.push(decoded.result);\n    childOffset += decoded.consumed;\n\n    if (childOffset > offset + 1 + length) {\n      logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n  }\n\n  return {\n    consumed: 1 + length,\n    result: result\n  };\n} // returns { consumed: number, result: Object }\n\n\nfunction _decode(data, offset) {\n  if (data.length === 0) {\n    logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n  } // Array with extra length prefix\n\n\n  if (data[offset] >= 0xf8) {\n    const lengthLength = data[offset] - 0xf7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n  } else if (data[offset] >= 0xc0) {\n    const length = data[offset] - 0xc0;\n\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    return _decodeChildren(data, offset, offset + 1, length);\n  } else if (data[offset] >= 0xb8) {\n    const lengthLength = data[offset] - 0xb7;\n\n    if (offset + 1 + lengthLength > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const length = unarrayifyInteger(data, offset + 1, lengthLength);\n\n    if (offset + 1 + lengthLength + length > data.length) {\n      logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n    return {\n      consumed: 1 + lengthLength + length,\n      result: result\n    };\n  } else if (data[offset] >= 0x80) {\n    const length = data[offset] - 0x80;\n\n    if (offset + 1 + length > data.length) {\n      logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n\n    const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n    return {\n      consumed: 1 + length,\n      result: result\n    };\n  }\n\n  return {\n    consumed: 1,\n    result: hexlify(data[offset])\n  };\n}\n\nexport function decode(data) {\n  const bytes = arrayify(data);\n\n  const decoded = _decode(bytes, 0);\n\n  if (decoded.consumed !== bytes.length) {\n    logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n  }\n\n  return decoded.result;\n}","map":{"version":3,"names":["arrayify","hexlify","isBytesLike","Logger","version","logger","arrayifyInteger","value","result","unshift","unarrayifyInteger","data","offset","length","i","_encode","object","Array","isArray","payload","forEach","child","concat","throwArgumentError","prototype","slice","call","encode","_decodeChildren","childOffset","decoded","_decode","push","consumed","throwError","errors","BUFFER_OVERRUN","lengthLength","decode","bytes"],"sources":["/Users/annasudol/Documents/encode/Project4-Group3-Encode/frontend/node_modules/@ethersproject/rlp/lib.esm/index.js"],"sourcesContent":["\"use strict\";\n//See: https://github.com/ethereum/wiki/wiki/RLP\nimport { arrayify, hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction arrayifyInteger(value) {\n    const result = [];\n    while (value) {\n        result.unshift(value & 0xff);\n        value >>= 8;\n    }\n    return result;\n}\nfunction unarrayifyInteger(data, offset, length) {\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n        result = (result * 256) + data[offset + i];\n    }\n    return result;\n}\nfunction _encode(object) {\n    if (Array.isArray(object)) {\n        let payload = [];\n        object.forEach(function (child) {\n            payload = payload.concat(_encode(child));\n        });\n        if (payload.length <= 55) {\n            payload.unshift(0xc0 + payload.length);\n            return payload;\n        }\n        const length = arrayifyInteger(payload.length);\n        length.unshift(0xf7 + length.length);\n        return length.concat(payload);\n    }\n    if (!isBytesLike(object)) {\n        logger.throwArgumentError(\"RLP object must be BytesLike\", \"object\", object);\n    }\n    const data = Array.prototype.slice.call(arrayify(object));\n    if (data.length === 1 && data[0] <= 0x7f) {\n        return data;\n    }\n    else if (data.length <= 55) {\n        data.unshift(0x80 + data.length);\n        return data;\n    }\n    const length = arrayifyInteger(data.length);\n    length.unshift(0xb7 + length.length);\n    return length.concat(data);\n}\nexport function encode(object) {\n    return hexlify(_encode(object));\n}\nfunction _decodeChildren(data, offset, childOffset, length) {\n    const result = [];\n    while (childOffset < offset + 1 + length) {\n        const decoded = _decode(data, childOffset);\n        result.push(decoded.result);\n        childOffset += decoded.consumed;\n        if (childOffset > offset + 1 + length) {\n            logger.throwError(\"child data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n    }\n    return { consumed: (1 + length), result: result };\n}\n// returns { consumed: number, result: Object }\nfunction _decode(data, offset) {\n    if (data.length === 0) {\n        logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n    }\n    // Array with extra length prefix\n    if (data[offset] >= 0xf8) {\n        const lengthLength = data[offset] - 0xf7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data short segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data long segment too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);\n    }\n    else if (data[offset] >= 0xc0) {\n        const length = data[offset] - 0xc0;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        return _decodeChildren(data, offset, offset + 1, length);\n    }\n    else if (data[offset] >= 0xb8) {\n        const lengthLength = data[offset] - 0xb7;\n        if (offset + 1 + lengthLength > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const length = unarrayifyInteger(data, offset + 1, lengthLength);\n        if (offset + 1 + lengthLength + length > data.length) {\n            logger.throwError(\"data array too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));\n        return { consumed: (1 + lengthLength + length), result: result };\n    }\n    else if (data[offset] >= 0x80) {\n        const length = data[offset] - 0x80;\n        if (offset + 1 + length > data.length) {\n            logger.throwError(\"data too short\", Logger.errors.BUFFER_OVERRUN, {});\n        }\n        const result = hexlify(data.slice(offset + 1, offset + 1 + length));\n        return { consumed: (1 + length), result: result };\n    }\n    return { consumed: 1, result: hexlify(data[offset]) };\n}\nexport function decode(data) {\n    const bytes = arrayify(data);\n    const decoded = _decode(bytes, 0);\n    if (decoded.consumed !== bytes.length) {\n        logger.throwArgumentError(\"invalid rlp data\", \"data\", data);\n    }\n    return decoded.result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}