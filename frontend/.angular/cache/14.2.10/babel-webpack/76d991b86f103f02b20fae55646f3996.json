{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { arrayify, concat, hexDataSlice, isHexString, joinSignature } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction isAccount(value) {\n  return value != null && isHexString(value.privateKey, 32) && value.address != null;\n}\n\nfunction hasMnemonic(value) {\n  const mnemonic = value.mnemonic;\n  return mnemonic && mnemonic.phrase;\n}\n\nexport class Wallet extends Signer {\n  constructor(privateKey, provider) {\n    super();\n\n    if (isAccount(privateKey)) {\n      const signingKey = new SigningKey(privateKey.privateKey);\n      defineReadOnly(this, \"_signingKey\", () => signingKey);\n      defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n\n      if (this.address !== getAddress(privateKey.address)) {\n        logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n      }\n\n      if (hasMnemonic(privateKey)) {\n        const srcMnemonic = privateKey.mnemonic;\n        defineReadOnly(this, \"_mnemonic\", () => ({\n          phrase: srcMnemonic.phrase,\n          path: srcMnemonic.path || defaultPath,\n          locale: srcMnemonic.locale || \"en\"\n        }));\n        const mnemonic = this.mnemonic;\n        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n\n        if (computeAddress(node.privateKey) !== this.address) {\n          logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n        }\n      } else {\n        defineReadOnly(this, \"_mnemonic\", () => null);\n      }\n    } else {\n      if (SigningKey.isSigningKey(privateKey)) {\n        /* istanbul ignore if */\n        if (privateKey.curve !== \"secp256k1\") {\n          logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n        }\n\n        defineReadOnly(this, \"_signingKey\", () => privateKey);\n      } else {\n        // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n        if (typeof privateKey === \"string\") {\n          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n            privateKey = \"0x\" + privateKey;\n          }\n        }\n\n        const signingKey = new SigningKey(privateKey);\n        defineReadOnly(this, \"_signingKey\", () => signingKey);\n      }\n\n      defineReadOnly(this, \"_mnemonic\", () => null);\n      defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n    }\n    /* istanbul ignore if */\n\n\n    if (provider && !Provider.isProvider(provider)) {\n      logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n    }\n\n    defineReadOnly(this, \"provider\", provider || null);\n  }\n\n  get mnemonic() {\n    return this._mnemonic();\n  }\n\n  get privateKey() {\n    return this._signingKey().privateKey;\n  }\n\n  get publicKey() {\n    return this._signingKey().publicKey;\n  }\n\n  getAddress() {\n    return Promise.resolve(this.address);\n  }\n\n  connect(provider) {\n    return new Wallet(this, provider);\n  }\n\n  signTransaction(transaction) {\n    return resolveProperties(transaction).then(tx => {\n      if (tx.from != null) {\n        if (getAddress(tx.from) !== this.address) {\n          logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n        }\n\n        delete tx.from;\n      }\n\n      const signature = this._signingKey().signDigest(keccak256(serialize(tx)));\n\n      return serialize(tx, signature);\n    });\n  }\n\n  signMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n    });\n  }\n\n  _signTypedData(domain, types, value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Populate any ENS names\n      const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, name => {\n        if (this.provider == null) {\n          logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resolveName\",\n            value: name\n          });\n        }\n\n        return this.provider.resolveName(name);\n      });\n      return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n    });\n  }\n\n  encrypt(password, options, progressCallback) {\n    if (typeof options === \"function\" && !progressCallback) {\n      progressCallback = options;\n      options = {};\n    }\n\n    if (progressCallback && typeof progressCallback !== \"function\") {\n      throw new Error(\"invalid callback\");\n    }\n\n    if (!options) {\n      options = {};\n    }\n\n    return encryptKeystore(this, password, options, progressCallback);\n  }\n  /**\n   *  Static methods to create Wallet instances.\n   */\n\n\n  static createRandom(options) {\n    let entropy = randomBytes(16);\n\n    if (!options) {\n      options = {};\n    }\n\n    if (options.extraEntropy) {\n      entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));\n    }\n\n    const mnemonic = entropyToMnemonic(entropy, options.locale);\n    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n  }\n\n  static fromEncryptedJson(json, password, progressCallback) {\n    return decryptJsonWallet(json, password, progressCallback).then(account => {\n      return new Wallet(account);\n    });\n  }\n\n  static fromEncryptedJsonSync(json, password) {\n    return new Wallet(decryptJsonWalletSync(json, password));\n  }\n\n  static fromMnemonic(mnemonic, path, wordlist) {\n    if (!path) {\n      path = defaultPath;\n    }\n\n    return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n  }\n\n}\nexport function verifyMessage(message, signature) {\n  return recoverAddress(hashMessage(message), signature);\n}\nexport function verifyTypedData(domain, types, value, signature) {\n  return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","getAddress","Provider","Signer","arrayify","concat","hexDataSlice","isHexString","joinSignature","hashMessage","_TypedDataEncoder","defaultPath","HDNode","entropyToMnemonic","keccak256","defineReadOnly","resolveProperties","randomBytes","SigningKey","decryptJsonWallet","decryptJsonWalletSync","encryptKeystore","computeAddress","recoverAddress","serialize","Logger","version","logger","isAccount","privateKey","address","hasMnemonic","mnemonic","phrase","Wallet","constructor","provider","signingKey","publicKey","throwArgumentError","srcMnemonic","path","locale","node","fromMnemonic","derivePath","isSigningKey","curve","match","length","isProvider","_mnemonic","_signingKey","connect","signTransaction","transaction","tx","from","signature","signDigest","signMessage","message","_signTypedData","domain","types","populated","resolveNames","name","throwError","errors","UNSUPPORTED_OPERATION","operation","resolveName","hash","encrypt","password","options","progressCallback","Error","createRandom","entropy","extraEntropy","fromEncryptedJson","json","account","fromEncryptedJsonSync","wordlist","verifyMessage","verifyTypedData"],"sources":["/Users/annasudol/Documents/encode/Project4-Group3-Encode/frontend/node_modules/@ethersproject/wallet/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { arrayify, concat, hexDataSlice, isHexString, joinSignature } from \"@ethersproject/bytes\";\nimport { hashMessage, _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { defaultPath, HDNode, entropyToMnemonic } from \"@ethersproject/hdnode\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { randomBytes } from \"@ethersproject/random\";\nimport { SigningKey } from \"@ethersproject/signing-key\";\nimport { decryptJsonWallet, decryptJsonWalletSync, encryptKeystore } from \"@ethersproject/json-wallets\";\nimport { computeAddress, recoverAddress, serialize } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction isAccount(value) {\n    return (value != null && isHexString(value.privateKey, 32) && value.address != null);\n}\nfunction hasMnemonic(value) {\n    const mnemonic = value.mnemonic;\n    return (mnemonic && mnemonic.phrase);\n}\nexport class Wallet extends Signer {\n    constructor(privateKey, provider) {\n        super();\n        if (isAccount(privateKey)) {\n            const signingKey = new SigningKey(privateKey.privateKey);\n            defineReadOnly(this, \"_signingKey\", () => signingKey);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n            if (this.address !== getAddress(privateKey.address)) {\n                logger.throwArgumentError(\"privateKey/address mismatch\", \"privateKey\", \"[REDACTED]\");\n            }\n            if (hasMnemonic(privateKey)) {\n                const srcMnemonic = privateKey.mnemonic;\n                defineReadOnly(this, \"_mnemonic\", () => ({\n                    phrase: srcMnemonic.phrase,\n                    path: srcMnemonic.path || defaultPath,\n                    locale: srcMnemonic.locale || \"en\"\n                }));\n                const mnemonic = this.mnemonic;\n                const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n                if (computeAddress(node.privateKey) !== this.address) {\n                    logger.throwArgumentError(\"mnemonic/address mismatch\", \"privateKey\", \"[REDACTED]\");\n                }\n            }\n            else {\n                defineReadOnly(this, \"_mnemonic\", () => null);\n            }\n        }\n        else {\n            if (SigningKey.isSigningKey(privateKey)) {\n                /* istanbul ignore if */\n                if (privateKey.curve !== \"secp256k1\") {\n                    logger.throwArgumentError(\"unsupported curve; must be secp256k1\", \"privateKey\", \"[REDACTED]\");\n                }\n                defineReadOnly(this, \"_signingKey\", () => privateKey);\n            }\n            else {\n                // A lot of common tools do not prefix private keys with a 0x (see: #1166)\n                if (typeof (privateKey) === \"string\") {\n                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n                        privateKey = \"0x\" + privateKey;\n                    }\n                }\n                const signingKey = new SigningKey(privateKey);\n                defineReadOnly(this, \"_signingKey\", () => signingKey);\n            }\n            defineReadOnly(this, \"_mnemonic\", () => null);\n            defineReadOnly(this, \"address\", computeAddress(this.publicKey));\n        }\n        /* istanbul ignore if */\n        if (provider && !Provider.isProvider(provider)) {\n            logger.throwArgumentError(\"invalid provider\", \"provider\", provider);\n        }\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n    get mnemonic() { return this._mnemonic(); }\n    get privateKey() { return this._signingKey().privateKey; }\n    get publicKey() { return this._signingKey().publicKey; }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    connect(provider) {\n        return new Wallet(this, provider);\n    }\n    signTransaction(transaction) {\n        return resolveProperties(transaction).then((tx) => {\n            if (tx.from != null) {\n                if (getAddress(tx.from) !== this.address) {\n                    logger.throwArgumentError(\"transaction from address mismatch\", \"transaction.from\", transaction.from);\n                }\n                delete tx.from;\n            }\n            const signature = this._signingKey().signDigest(keccak256(serialize(tx)));\n            return serialize(tx, signature);\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return joinSignature(this._signingKey().signDigest(hashMessage(message)));\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                if (this.provider == null) {\n                    logger.throwError(\"cannot resolve ENS names without a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                        operation: \"resolveName\",\n                        value: name\n                    });\n                }\n                return this.provider.resolveName(name);\n            });\n            return joinSignature(this._signingKey().signDigest(_TypedDataEncoder.hash(populated.domain, types, populated.value)));\n        });\n    }\n    encrypt(password, options, progressCallback) {\n        if (typeof (options) === \"function\" && !progressCallback) {\n            progressCallback = options;\n            options = {};\n        }\n        if (progressCallback && typeof (progressCallback) !== \"function\") {\n            throw new Error(\"invalid callback\");\n        }\n        if (!options) {\n            options = {};\n        }\n        return encryptKeystore(this, password, options, progressCallback);\n    }\n    /**\n     *  Static methods to create Wallet instances.\n     */\n    static createRandom(options) {\n        let entropy = randomBytes(16);\n        if (!options) {\n            options = {};\n        }\n        if (options.extraEntropy) {\n            entropy = arrayify(hexDataSlice(keccak256(concat([entropy, options.extraEntropy])), 0, 16));\n        }\n        const mnemonic = entropyToMnemonic(entropy, options.locale);\n        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n    }\n    static fromEncryptedJson(json, password, progressCallback) {\n        return decryptJsonWallet(json, password, progressCallback).then((account) => {\n            return new Wallet(account);\n        });\n    }\n    static fromEncryptedJsonSync(json, password) {\n        return new Wallet(decryptJsonWalletSync(json, password));\n    }\n    static fromMnemonic(mnemonic, path, wordlist) {\n        if (!path) {\n            path = defaultPath;\n        }\n        return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n    }\n}\nexport function verifyMessage(message, signature) {\n    return recoverAddress(hashMessage(message), signature);\n}\nexport function verifyTypedData(domain, types, value, signature) {\n    return recoverAddress(_TypedDataEncoder.hash(domain, types, value), signature);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}