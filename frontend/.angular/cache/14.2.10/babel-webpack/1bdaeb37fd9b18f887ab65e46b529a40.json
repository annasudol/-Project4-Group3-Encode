{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { checkResultErrors, Indexed, Interface } from \"@ethersproject/abi\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n; ///////////////////////////////\n\nconst allowedTransactionKeys = {\n  chainId: true,\n  data: true,\n  from: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  type: true,\n  accessList: true,\n  maxFeePerGas: true,\n  maxPriorityFeePerGas: true,\n  customData: true,\n  ccipReadEnabled: true\n};\n\nfunction resolveName(resolver, nameOrPromise) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const name = yield nameOrPromise;\n\n    if (typeof name !== \"string\") {\n      logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n    } // If it is already an address, just use it (after adding checksum)\n\n\n    try {\n      return getAddress(name);\n    } catch (error) {}\n\n    if (!resolver) {\n      logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"resolveName\"\n      });\n    }\n\n    const address = yield resolver.resolveName(name);\n\n    if (address == null) {\n      logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n    }\n\n    return address;\n  });\n} // Recursively replaces ENS names with promises to resolve the name and resolves all properties\n\n\nfunction resolveAddresses(resolver, value, paramType) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (Array.isArray(paramType)) {\n      return yield Promise.all(paramType.map((paramType, index) => {\n        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);\n      }));\n    }\n\n    if (paramType.type === \"address\") {\n      return yield resolveName(resolver, value);\n    }\n\n    if (paramType.type === \"tuple\") {\n      return yield resolveAddresses(resolver, value, paramType.components);\n    }\n\n    if (paramType.baseType === \"array\") {\n      if (!Array.isArray(value)) {\n        return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n          argument: \"value\",\n          value\n        }));\n      }\n\n      return yield Promise.all(value.map(v => resolveAddresses(resolver, v, paramType.arrayChildren)));\n    }\n\n    return value;\n  });\n}\n\nfunction populateTransaction(contract, fragment, args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // If an extra argument is given, it is overrides\n    let overrides = {};\n\n    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n      overrides = shallowCopy(args.pop());\n    } // Make sure the parameter count matches\n\n\n    logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\"); // Populate \"from\" override (allow promises)\n\n    if (contract.signer) {\n      if (overrides.from) {\n        // Contracts with a Signer are from the Signer's frame-of-reference;\n        // but we allow overriding \"from\" if it matches the signer\n        overrides.from = resolveProperties({\n          override: resolveName(contract.signer, overrides.from),\n          signer: contract.signer.getAddress()\n        }).then(check => __awaiter(this, void 0, void 0, function* () {\n          if (getAddress(check.signer) !== check.override) {\n            logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n              operation: \"overrides.from\"\n            });\n          }\n\n          return check.override;\n        }));\n      } else {\n        overrides.from = contract.signer.getAddress();\n      }\n    } else if (overrides.from) {\n      overrides.from = resolveName(contract.provider, overrides.from); //} else {\n      // Contracts without a signer can override \"from\", and if\n      // unspecified the zero address is used\n      //overrides.from = AddressZero;\n    } // Wait for all dependencies to be resolved (prefer the signer over the provider)\n\n\n    const resolved = yield resolveProperties({\n      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n      address: contract.resolvedAddress,\n      overrides: resolveProperties(overrides) || {}\n    }); // The ABI coded transaction\n\n    const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n    const tx = {\n      data: data,\n      to: resolved.address\n    }; // Resolved Overrides\n\n    const ro = resolved.overrides; // Populate simple overrides\n\n    if (ro.nonce != null) {\n      tx.nonce = BigNumber.from(ro.nonce).toNumber();\n    }\n\n    if (ro.gasLimit != null) {\n      tx.gasLimit = BigNumber.from(ro.gasLimit);\n    }\n\n    if (ro.gasPrice != null) {\n      tx.gasPrice = BigNumber.from(ro.gasPrice);\n    }\n\n    if (ro.maxFeePerGas != null) {\n      tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);\n    }\n\n    if (ro.maxPriorityFeePerGas != null) {\n      tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);\n    }\n\n    if (ro.from != null) {\n      tx.from = ro.from;\n    }\n\n    if (ro.type != null) {\n      tx.type = ro.type;\n    }\n\n    if (ro.accessList != null) {\n      tx.accessList = accessListify(ro.accessList);\n    } // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n\n\n    if (tx.gasLimit == null && fragment.gas != null) {\n      // Compute the intrinsic gas cost for this transaction\n      // @TODO: This is based on the yellow paper as of Petersburg; this is something\n      // we may wish to parameterize in v6 as part of the Network object. Since this\n      // is always a non-nil to address, we can ignore G_create, but may wish to add\n      // similar logic to the ContractFactory.\n      let intrinsic = 21000;\n      const bytes = arrayify(data);\n\n      for (let i = 0; i < bytes.length; i++) {\n        intrinsic += 4;\n\n        if (bytes[i]) {\n          intrinsic += 64;\n        }\n      }\n\n      tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n    } // Populate \"value\" override\n\n\n    if (ro.value) {\n      const roValue = BigNumber.from(ro.value);\n\n      if (!roValue.isZero() && !fragment.payable) {\n        logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"overrides.value\",\n          value: overrides.value\n        });\n      }\n\n      tx.value = roValue;\n    }\n\n    if (ro.customData) {\n      tx.customData = shallowCopy(ro.customData);\n    }\n\n    if (ro.ccipReadEnabled) {\n      tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n    } // Remove the overrides\n\n\n    delete overrides.nonce;\n    delete overrides.gasLimit;\n    delete overrides.gasPrice;\n    delete overrides.from;\n    delete overrides.value;\n    delete overrides.type;\n    delete overrides.accessList;\n    delete overrides.maxFeePerGas;\n    delete overrides.maxPriorityFeePerGas;\n    delete overrides.customData;\n    delete overrides.ccipReadEnabled; // Make sure there are no stray overrides, which may indicate a\n    // typo or using an unsupported key.\n\n    const leftovers = Object.keys(overrides).filter(key => overrides[key] != null);\n\n    if (leftovers.length) {\n      logger.throwError(`cannot override ${leftovers.map(l => JSON.stringify(l)).join(\",\")}`, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"overrides\",\n        overrides: leftovers\n      });\n    }\n\n    return tx;\n  });\n}\n\nfunction buildPopulate(contract, fragment) {\n  return function (...args) {\n    return populateTransaction(contract, fragment, args);\n  };\n}\n\nfunction buildEstimate(contract, fragment) {\n  const signerOrProvider = contract.signer || contract.provider;\n  return function (...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!signerOrProvider) {\n        logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"estimateGas\"\n        });\n      }\n\n      const tx = yield populateTransaction(contract, fragment, args);\n      return yield signerOrProvider.estimateGas(tx);\n    });\n  };\n}\n\nfunction addContractWait(contract, tx) {\n  const wait = tx.wait.bind(tx);\n\n  tx.wait = confirmations => {\n    return wait(confirmations).then(receipt => {\n      receipt.events = receipt.logs.map(log => {\n        let event = deepCopy(log);\n        let parsed = null;\n\n        try {\n          parsed = contract.interface.parseLog(log);\n        } catch (e) {} // Successfully parsed the event log; include it\n\n\n        if (parsed) {\n          event.args = parsed.args;\n\n          event.decode = (data, topics) => {\n            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n          };\n\n          event.event = parsed.name;\n          event.eventSignature = parsed.signature;\n        } // Useful operations\n\n\n        event.removeListener = () => {\n          return contract.provider;\n        };\n\n        event.getBlock = () => {\n          return contract.provider.getBlock(receipt.blockHash);\n        };\n\n        event.getTransaction = () => {\n          return contract.provider.getTransaction(receipt.transactionHash);\n        };\n\n        event.getTransactionReceipt = () => {\n          return Promise.resolve(receipt);\n        };\n\n        return event;\n      });\n      return receipt;\n    });\n  };\n}\n\nfunction buildCall(contract, fragment, collapseSimple) {\n  const signerOrProvider = contract.signer || contract.provider;\n  return function (...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Extract the \"blockTag\" override if present\n      let blockTag = undefined;\n\n      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n        const overrides = shallowCopy(args.pop());\n\n        if (overrides.blockTag != null) {\n          blockTag = yield overrides.blockTag;\n        }\n\n        delete overrides.blockTag;\n        args.push(overrides);\n      } // If the contract was just deployed, wait until it is mined\n\n\n      if (contract.deployTransaction != null) {\n        yield contract._deployed(blockTag);\n      } // Call a node and get the result\n\n\n      const tx = yield populateTransaction(contract, fragment, args);\n      const result = yield signerOrProvider.call(tx, blockTag);\n\n      try {\n        let value = contract.interface.decodeFunctionResult(fragment, result);\n\n        if (collapseSimple && fragment.outputs.length === 1) {\n          value = value[0];\n        }\n\n        return value;\n      } catch (error) {\n        if (error.code === Logger.errors.CALL_EXCEPTION) {\n          error.address = contract.address;\n          error.args = args;\n          error.transaction = tx;\n        }\n\n        throw error;\n      }\n    });\n  };\n}\n\nfunction buildSend(contract, fragment) {\n  return function (...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!contract.signer) {\n        logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"sendTransaction\"\n        });\n      } // If the contract was just deployed, wait until it is mined\n\n\n      if (contract.deployTransaction != null) {\n        yield contract._deployed();\n      }\n\n      const txRequest = yield populateTransaction(contract, fragment, args);\n      const tx = yield contract.signer.sendTransaction(txRequest); // Tweak the tx.wait so the receipt has extra properties\n\n      addContractWait(contract, tx);\n      return tx;\n    });\n  };\n}\n\nfunction buildDefault(contract, fragment, collapseSimple) {\n  if (fragment.constant) {\n    return buildCall(contract, fragment, collapseSimple);\n  }\n\n  return buildSend(contract, fragment);\n}\n\nfunction getEventTag(filter) {\n  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n    return \"*\";\n  }\n\n  return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map(topic => {\n    if (Array.isArray(topic)) {\n      return topic.join(\"|\");\n    }\n\n    return topic;\n  }).join(\":\") : \"\");\n}\n\nclass RunningEvent {\n  constructor(tag, filter) {\n    defineReadOnly(this, \"tag\", tag);\n    defineReadOnly(this, \"filter\", filter);\n    this._listeners = [];\n  }\n\n  addListener(listener, once) {\n    this._listeners.push({\n      listener: listener,\n      once: once\n    });\n  }\n\n  removeListener(listener) {\n    let done = false;\n    this._listeners = this._listeners.filter(item => {\n      if (done || item.listener !== listener) {\n        return true;\n      }\n\n      done = true;\n      return false;\n    });\n  }\n\n  removeAllListeners() {\n    this._listeners = [];\n  }\n\n  listeners() {\n    return this._listeners.map(i => i.listener);\n  }\n\n  listenerCount() {\n    return this._listeners.length;\n  }\n\n  run(args) {\n    const listenerCount = this.listenerCount();\n    this._listeners = this._listeners.filter(item => {\n      const argsCopy = args.slice(); // Call the callback in the next event loop\n\n      setTimeout(() => {\n        item.listener.apply(this, argsCopy);\n      }, 0); // Reschedule it if it not \"once\"\n\n      return !item.once;\n    });\n    return listenerCount;\n  }\n\n  prepareEvent(event) {} // Returns the array that will be applied to an emit\n\n\n  getEmit(event) {\n    return [event];\n  }\n\n}\n\nclass ErrorRunningEvent extends RunningEvent {\n  constructor() {\n    super(\"error\", null);\n  }\n\n} // @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\n\n\nclass FragmentRunningEvent extends RunningEvent {\n  constructor(address, contractInterface, fragment, topics) {\n    const filter = {\n      address: address\n    };\n    let topic = contractInterface.getEventTopic(fragment);\n\n    if (topics) {\n      if (topic !== topics[0]) {\n        logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n      }\n\n      filter.topics = topics.slice();\n    } else {\n      filter.topics = [topic];\n    }\n\n    super(getEventTag(filter), filter);\n    defineReadOnly(this, \"address\", address);\n    defineReadOnly(this, \"interface\", contractInterface);\n    defineReadOnly(this, \"fragment\", fragment);\n  }\n\n  prepareEvent(event) {\n    super.prepareEvent(event);\n    event.event = this.fragment.name;\n    event.eventSignature = this.fragment.format();\n\n    event.decode = (data, topics) => {\n      return this.interface.decodeEventLog(this.fragment, data, topics);\n    };\n\n    try {\n      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n    } catch (error) {\n      event.args = null;\n      event.decodeError = error;\n    }\n  }\n\n  getEmit(event) {\n    const errors = checkResultErrors(event.args);\n\n    if (errors.length) {\n      throw errors[0].error;\n    }\n\n    const args = (event.args || []).slice();\n    args.push(event);\n    return args;\n  }\n\n} // A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\n\n\nclass WildcardRunningEvent extends RunningEvent {\n  constructor(address, contractInterface) {\n    super(\"*\", {\n      address: address\n    });\n    defineReadOnly(this, \"address\", address);\n    defineReadOnly(this, \"interface\", contractInterface);\n  }\n\n  prepareEvent(event) {\n    super.prepareEvent(event);\n\n    try {\n      const parsed = this.interface.parseLog(event);\n      event.event = parsed.name;\n      event.eventSignature = parsed.signature;\n\n      event.decode = (data, topics) => {\n        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n      };\n\n      event.args = parsed.args;\n    } catch (error) {// No matching event\n    }\n  }\n\n}\n\nexport class BaseContract {\n  constructor(addressOrName, contractInterface, signerOrProvider) {\n    // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n    //address = getAddress(address);\n    defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n\n    if (signerOrProvider == null) {\n      defineReadOnly(this, \"provider\", null);\n      defineReadOnly(this, \"signer\", null);\n    } else if (Signer.isSigner(signerOrProvider)) {\n      defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n      defineReadOnly(this, \"signer\", signerOrProvider);\n    } else if (Provider.isProvider(signerOrProvider)) {\n      defineReadOnly(this, \"provider\", signerOrProvider);\n      defineReadOnly(this, \"signer\", null);\n    } else {\n      logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n    }\n\n    defineReadOnly(this, \"callStatic\", {});\n    defineReadOnly(this, \"estimateGas\", {});\n    defineReadOnly(this, \"functions\", {});\n    defineReadOnly(this, \"populateTransaction\", {});\n    defineReadOnly(this, \"filters\", {});\n    {\n      const uniqueFilters = {};\n      Object.keys(this.interface.events).forEach(eventSignature => {\n        const event = this.interface.events[eventSignature];\n        defineReadOnly(this.filters, eventSignature, (...args) => {\n          return {\n            address: this.address,\n            topics: this.interface.encodeFilterTopics(event, args)\n          };\n        });\n\n        if (!uniqueFilters[event.name]) {\n          uniqueFilters[event.name] = [];\n        }\n\n        uniqueFilters[event.name].push(eventSignature);\n      });\n      Object.keys(uniqueFilters).forEach(name => {\n        const filters = uniqueFilters[name];\n\n        if (filters.length === 1) {\n          defineReadOnly(this.filters, name, this.filters[filters[0]]);\n        } else {\n          logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n        }\n      });\n    }\n    defineReadOnly(this, \"_runningEvents\", {});\n    defineReadOnly(this, \"_wrappedEmits\", {});\n\n    if (addressOrName == null) {\n      logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n    }\n\n    defineReadOnly(this, \"address\", addressOrName);\n\n    if (this.provider) {\n      defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n    } else {\n      try {\n        defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n      } catch (error) {\n        // Without a provider, we cannot use ENS names\n        logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"new Contract\"\n        });\n      }\n    } // Swallow bad ENS names to prevent Unhandled Exceptions\n\n\n    this.resolvedAddress.catch(e => {});\n    const uniqueNames = {};\n    const uniqueSignatures = {};\n    Object.keys(this.interface.functions).forEach(signature => {\n      const fragment = this.interface.functions[signature]; // Check that the signature is unique; if not the ABI generation has\n      // not been cleaned or may be incorrectly generated\n\n      if (uniqueSignatures[signature]) {\n        logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n        return;\n      }\n\n      uniqueSignatures[signature] = true; // Track unique names; we only expose bare named functions if they\n      // are ambiguous\n\n      {\n        const name = fragment.name;\n\n        if (!uniqueNames[`%${name}`]) {\n          uniqueNames[`%${name}`] = [];\n        }\n\n        uniqueNames[`%${name}`].push(signature);\n      }\n\n      if (this[signature] == null) {\n        defineReadOnly(this, signature, buildDefault(this, fragment, true));\n      } // We do not collapse simple calls on this bucket, which allows\n      // frameworks to safely use this without introspection as well as\n      // allows decoding error recovery.\n\n\n      if (this.functions[signature] == null) {\n        defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n      }\n\n      if (this.callStatic[signature] == null) {\n        defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n      }\n\n      if (this.populateTransaction[signature] == null) {\n        defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n      }\n\n      if (this.estimateGas[signature] == null) {\n        defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n      }\n    });\n    Object.keys(uniqueNames).forEach(name => {\n      // Ambiguous names to not get attached as bare names\n      const signatures = uniqueNames[name];\n\n      if (signatures.length > 1) {\n        return;\n      } // Strip off the leading \"%\" used for prototype protection\n\n\n      name = name.substring(1);\n      const signature = signatures[0]; // If overwriting a member property that is null, swallow the error\n\n      try {\n        if (this[name] == null) {\n          defineReadOnly(this, name, this[signature]);\n        }\n      } catch (e) {}\n\n      if (this.functions[name] == null) {\n        defineReadOnly(this.functions, name, this.functions[signature]);\n      }\n\n      if (this.callStatic[name] == null) {\n        defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n      }\n\n      if (this.populateTransaction[name] == null) {\n        defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n      }\n\n      if (this.estimateGas[name] == null) {\n        defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n      }\n    });\n  }\n\n  static getContractAddress(transaction) {\n    return getContractAddress(transaction);\n  }\n\n  static getInterface(contractInterface) {\n    if (Interface.isInterface(contractInterface)) {\n      return contractInterface;\n    }\n\n    return new Interface(contractInterface);\n  } // @TODO: Allow timeout?\n\n\n  deployed() {\n    return this._deployed();\n  }\n\n  _deployed(blockTag) {\n    if (!this._deployedPromise) {\n      // If we were just deployed, we know the transaction we should occur in\n      if (this.deployTransaction) {\n        this._deployedPromise = this.deployTransaction.wait().then(() => {\n          return this;\n        });\n      } else {\n        // @TODO: Once we allow a timeout to be passed in, we will wait\n        // up to that many blocks for getCode\n        // Otherwise, poll for our code to be deployed\n        this._deployedPromise = this.provider.getCode(this.address, blockTag).then(code => {\n          if (code === \"0x\") {\n            logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n              contractAddress: this.address,\n              operation: \"getDeployed\"\n            });\n          }\n\n          return this;\n        });\n      }\n    }\n\n    return this._deployedPromise;\n  } // @TODO:\n  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n  // @TODO:\n  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\n\n  fallback(overrides) {\n    if (!this.signer) {\n      logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"sendTransaction(fallback)\"\n      });\n    }\n\n    const tx = shallowCopy(overrides || {});\n    [\"from\", \"to\"].forEach(function (key) {\n      if (tx[key] == null) {\n        return;\n      }\n\n      logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n    tx.to = this.resolvedAddress;\n    return this.deployed().then(() => {\n      return this.signer.sendTransaction(tx);\n    });\n  } // Reconnect to a different signer or provider\n\n\n  connect(signerOrProvider) {\n    if (typeof signerOrProvider === \"string\") {\n      signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n    }\n\n    const contract = new this.constructor(this.address, this.interface, signerOrProvider);\n\n    if (this.deployTransaction) {\n      defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n    }\n\n    return contract;\n  } // Re-attach to a different on-chain instance of this contract\n\n\n  attach(addressOrName) {\n    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);\n  }\n\n  static isIndexed(value) {\n    return Indexed.isIndexed(value);\n  }\n\n  _normalizeRunningEvent(runningEvent) {\n    // Already have an instance of this event running; we can re-use it\n    if (this._runningEvents[runningEvent.tag]) {\n      return this._runningEvents[runningEvent.tag];\n    }\n\n    return runningEvent;\n  }\n\n  _getRunningEvent(eventName) {\n    if (typeof eventName === \"string\") {\n      // Listen for \"error\" events (if your contract has an error event, include\n      // the full signature to bypass this special event keyword)\n      if (eventName === \"error\") {\n        return this._normalizeRunningEvent(new ErrorRunningEvent());\n      } // Listen for any event that is registered\n\n\n      if (eventName === \"event\") {\n        return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n      } // Listen for any event\n\n\n      if (eventName === \"*\") {\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n      } // Get the event Fragment (throws if ambiguous/unknown event)\n\n\n      const fragment = this.interface.getEvent(eventName);\n      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n    } // We have topics to filter by...\n\n\n    if (eventName.topics && eventName.topics.length > 0) {\n      // Is it a known topichash? (throws if no matching topichash)\n      try {\n        const topic = eventName.topics[0];\n\n        if (typeof topic !== \"string\") {\n          throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n        }\n\n        const fragment = this.interface.getEvent(topic);\n        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n      } catch (error) {} // Filter by the unknown topichash\n\n\n      const filter = {\n        address: this.address,\n        topics: eventName.topics\n      };\n      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n    }\n\n    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n  }\n\n  _checkRunningEvents(runningEvent) {\n    if (runningEvent.listenerCount() === 0) {\n      delete this._runningEvents[runningEvent.tag]; // If we have a poller for this, remove it\n\n      const emit = this._wrappedEmits[runningEvent.tag];\n\n      if (emit && runningEvent.filter) {\n        this.provider.off(runningEvent.filter, emit);\n        delete this._wrappedEmits[runningEvent.tag];\n      }\n    }\n  } // Subclasses can override this to gracefully recover\n  // from parse errors if they wish\n\n\n  _wrapEvent(runningEvent, log, listener) {\n    const event = deepCopy(log);\n\n    event.removeListener = () => {\n      if (!listener) {\n        return;\n      }\n\n      runningEvent.removeListener(listener);\n\n      this._checkRunningEvents(runningEvent);\n    };\n\n    event.getBlock = () => {\n      return this.provider.getBlock(log.blockHash);\n    };\n\n    event.getTransaction = () => {\n      return this.provider.getTransaction(log.transactionHash);\n    };\n\n    event.getTransactionReceipt = () => {\n      return this.provider.getTransactionReceipt(log.transactionHash);\n    }; // This may throw if the topics and data mismatch the signature\n\n\n    runningEvent.prepareEvent(event);\n    return event;\n  }\n\n  _addEventListener(runningEvent, listener, once) {\n    if (!this.provider) {\n      logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"once\"\n      });\n    }\n\n    runningEvent.addListener(listener, once); // Track this running event and its listeners (may already be there; but no hard in updating)\n\n    this._runningEvents[runningEvent.tag] = runningEvent; // If we are not polling the provider, start polling\n\n    if (!this._wrappedEmits[runningEvent.tag]) {\n      const wrappedEmit = log => {\n        let event = this._wrapEvent(runningEvent, log, listener); // Try to emit the result for the parameterized event...\n\n\n        if (event.decodeError == null) {\n          try {\n            const args = runningEvent.getEmit(event);\n            this.emit(runningEvent.filter, ...args);\n          } catch (error) {\n            event.decodeError = error.error;\n          }\n        } // Always emit \"event\" for fragment-base events\n\n\n        if (runningEvent.filter != null) {\n          this.emit(\"event\", event);\n        } // Emit \"error\" if there was an error\n\n\n        if (event.decodeError != null) {\n          this.emit(\"error\", event.decodeError, event);\n        }\n      };\n\n      this._wrappedEmits[runningEvent.tag] = wrappedEmit; // Special events, like \"error\" do not have a filter\n\n      if (runningEvent.filter != null) {\n        this.provider.on(runningEvent.filter, wrappedEmit);\n      }\n    }\n  }\n\n  queryFilter(event, fromBlockOrBlockhash, toBlock) {\n    const runningEvent = this._getRunningEvent(event);\n\n    const filter = shallowCopy(runningEvent.filter);\n\n    if (typeof fromBlockOrBlockhash === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n      if (toBlock != null) {\n        logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n      }\n\n      filter.blockHash = fromBlockOrBlockhash;\n    } else {\n      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;\n      filter.toBlock = toBlock != null ? toBlock : \"latest\";\n    }\n\n    return this.provider.getLogs(filter).then(logs => {\n      return logs.map(log => this._wrapEvent(runningEvent, log, null));\n    });\n  }\n\n  on(event, listener) {\n    this._addEventListener(this._getRunningEvent(event), listener, false);\n\n    return this;\n  }\n\n  once(event, listener) {\n    this._addEventListener(this._getRunningEvent(event), listener, true);\n\n    return this;\n  }\n\n  emit(eventName, ...args) {\n    if (!this.provider) {\n      return false;\n    }\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    const result = runningEvent.run(args) > 0; // May have drained all the \"once\" events; check for living events\n\n    this._checkRunningEvents(runningEvent);\n\n    return result;\n  }\n\n  listenerCount(eventName) {\n    if (!this.provider) {\n      return 0;\n    }\n\n    if (eventName == null) {\n      return Object.keys(this._runningEvents).reduce((accum, key) => {\n        return accum + this._runningEvents[key].listenerCount();\n      }, 0);\n    }\n\n    return this._getRunningEvent(eventName).listenerCount();\n  }\n\n  listeners(eventName) {\n    if (!this.provider) {\n      return [];\n    }\n\n    if (eventName == null) {\n      const result = [];\n\n      for (let tag in this._runningEvents) {\n        this._runningEvents[tag].listeners().forEach(listener => {\n          result.push(listener);\n        });\n      }\n\n      return result;\n    }\n\n    return this._getRunningEvent(eventName).listeners();\n  }\n\n  removeAllListeners(eventName) {\n    if (!this.provider) {\n      return this;\n    }\n\n    if (eventName == null) {\n      for (const tag in this._runningEvents) {\n        const runningEvent = this._runningEvents[tag];\n        runningEvent.removeAllListeners();\n\n        this._checkRunningEvents(runningEvent);\n      }\n\n      return this;\n    } // Delete any listeners\n\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    runningEvent.removeAllListeners();\n\n    this._checkRunningEvents(runningEvent);\n\n    return this;\n  }\n\n  off(eventName, listener) {\n    if (!this.provider) {\n      return this;\n    }\n\n    const runningEvent = this._getRunningEvent(eventName);\n\n    runningEvent.removeListener(listener);\n\n    this._checkRunningEvents(runningEvent);\n\n    return this;\n  }\n\n  removeListener(eventName, listener) {\n    return this.off(eventName, listener);\n  }\n\n}\nexport class Contract extends BaseContract {}\nexport class ContractFactory {\n  constructor(contractInterface, bytecode, signer) {\n    let bytecodeHex = null;\n\n    if (typeof bytecode === \"string\") {\n      bytecodeHex = bytecode;\n    } else if (isBytes(bytecode)) {\n      bytecodeHex = hexlify(bytecode);\n    } else if (bytecode && typeof bytecode.object === \"string\") {\n      // Allow the bytecode object from the Solidity compiler\n      bytecodeHex = bytecode.object;\n    } else {\n      // Crash in the next verification step\n      bytecodeHex = \"!\";\n    } // Make sure it is 0x prefixed\n\n\n    if (bytecodeHex.substring(0, 2) !== \"0x\") {\n      bytecodeHex = \"0x\" + bytecodeHex;\n    } // Make sure the final result is valid bytecode\n\n\n    if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {\n      logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n    } // If we have a signer, make sure it is valid\n\n\n    if (signer && !Signer.isSigner(signer)) {\n      logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n    }\n\n    defineReadOnly(this, \"bytecode\", bytecodeHex);\n    defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n    defineReadOnly(this, \"signer\", signer || null);\n  } // @TODO: Future; rename to populateTransaction?\n\n\n  getDeployTransaction(...args) {\n    let tx = {}; // If we have 1 additional argument, we allow transaction overrides\n\n    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === \"object\") {\n      tx = shallowCopy(args.pop());\n\n      for (const key in tx) {\n        if (!allowedTransactionKeys[key]) {\n          throw new Error(\"unknown transaction override \" + key);\n        }\n      }\n    } // Do not allow these to be overridden in a deployment transaction\n\n\n    [\"data\", \"from\", \"to\"].forEach(key => {\n      if (tx[key] == null) {\n        return;\n      }\n\n      logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: key\n      });\n    });\n\n    if (tx.value) {\n      const value = BigNumber.from(tx.value);\n\n      if (!value.isZero() && !this.interface.deploy.payable) {\n        logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n          operation: \"overrides.value\",\n          value: tx.value\n        });\n      }\n    } // Make sure the call matches the constructor signature\n\n\n    logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\"); // Set the data to the bytecode + the encoded constructor arguments\n\n    tx.data = hexlify(concat([this.bytecode, this.interface.encodeDeploy(args)]));\n    return tx;\n  }\n\n  deploy(...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let overrides = {}; // If 1 extra parameter was passed in, it contains overrides\n\n      if (args.length === this.interface.deploy.inputs.length + 1) {\n        overrides = args.pop();\n      } // Make sure the call matches the constructor signature\n\n\n      logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\"); // Resolve ENS names and promises in the arguments\n\n      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n      params.push(overrides); // Get the deployment transaction (with optional overrides)\n\n      const unsignedTx = this.getDeployTransaction(...params); // Send the deployment transaction\n\n      const tx = yield this.signer.sendTransaction(unsignedTx);\n      const address = getStatic(this.constructor, \"getContractAddress\")(tx);\n      const contract = getStatic(this.constructor, \"getContract\")(address, this.interface, this.signer); // Add the modified wait that wraps events\n\n      addContractWait(contract, tx);\n      defineReadOnly(contract, \"deployTransaction\", tx);\n      return contract;\n    });\n  }\n\n  attach(address) {\n    return this.constructor.getContract(address, this.interface, this.signer);\n  }\n\n  connect(signer) {\n    return new this.constructor(this.interface, this.bytecode, signer);\n  }\n\n  static fromSolidity(compilerOutput, signer) {\n    if (compilerOutput == null) {\n      logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, {\n        argument: \"compilerOutput\"\n      });\n    }\n\n    if (typeof compilerOutput === \"string\") {\n      compilerOutput = JSON.parse(compilerOutput);\n    }\n\n    const abi = compilerOutput.abi;\n    let bytecode = null;\n\n    if (compilerOutput.bytecode) {\n      bytecode = compilerOutput.bytecode;\n    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n      bytecode = compilerOutput.evm.bytecode;\n    }\n\n    return new this(abi, bytecode, signer);\n  }\n\n  static getInterface(contractInterface) {\n    return Contract.getInterface(contractInterface);\n  }\n\n  static getContractAddress(tx) {\n    return getContractAddress(tx);\n  }\n\n  static getContract(address, contractInterface, signer) {\n    return new Contract(address, contractInterface, signer);\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","checkResultErrors","Indexed","Interface","Provider","Signer","VoidSigner","getAddress","getContractAddress","BigNumber","arrayify","concat","hexlify","isBytes","isHexString","defineReadOnly","deepCopy","getStatic","resolveProperties","shallowCopy","accessListify","Logger","version","logger","allowedTransactionKeys","chainId","data","from","gasLimit","gasPrice","nonce","to","type","accessList","maxFeePerGas","maxPriorityFeePerGas","customData","ccipReadEnabled","resolveName","resolver","nameOrPromise","name","throwArgumentError","error","throwError","errors","UNSUPPORTED_OPERATION","operation","address","resolveAddresses","paramType","Array","isArray","all","map","index","components","baseType","makeError","INVALID_ARGUMENT","argument","v","arrayChildren","populateTransaction","contract","fragment","args","overrides","length","inputs","pop","checkArgumentCount","signer","override","check","provider","resolved","resolvedAddress","interface","encodeFunctionData","tx","ro","toNumber","gas","intrinsic","bytes","i","add","roValue","isZero","payable","leftovers","Object","keys","filter","key","l","JSON","stringify","join","buildPopulate","buildEstimate","signerOrProvider","estimateGas","addContractWait","wait","bind","confirmations","receipt","events","logs","log","event","parsed","parseLog","decode","topics","decodeEventLog","eventFragment","eventSignature","signature","removeListener","getBlock","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","blockTag","undefined","push","deployTransaction","_deployed","call","decodeFunctionResult","outputs","code","CALL_EXCEPTION","transaction","buildSend","txRequest","sendTransaction","buildDefault","constant","getEventTag","topic","RunningEvent","constructor","tag","_listeners","addListener","listener","once","item","removeAllListeners","listeners","listenerCount","run","argsCopy","slice","setTimeout","prepareEvent","getEmit","ErrorRunningEvent","FragmentRunningEvent","contractInterface","getEventTopic","format","decodeError","WildcardRunningEvent","BaseContract","addressOrName","new","target","isSigner","isProvider","uniqueFilters","forEach","filters","encodeFilterTopics","warn","catch","uniqueNames","uniqueSignatures","functions","callStatic","signatures","substring","getInterface","isInterface","deployed","_deployedPromise","getCode","contractAddress","fallback","connect","attach","isIndexed","_normalizeRunningEvent","runningEvent","_runningEvents","_getRunningEvent","eventName","getEvent","Error","_checkRunningEvents","emit","_wrappedEmits","off","_wrapEvent","_addEventListener","wrappedEmit","on","queryFilter","fromBlockOrBlockhash","toBlock","fromBlock","getLogs","reduce","accum","Contract","ContractFactory","bytecode","bytecodeHex","object","getDeployTransaction","deploy","encodeDeploy","params","unsignedTx","getContract","fromSolidity","compilerOutput","MISSING_ARGUMENT","parse","abi","evm"],"sources":["/Users/annasudol/Documents/encode/Project4-Group3-Encode/frontend/node_modules/@ethersproject/contracts/lib.esm/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { checkResultErrors, Indexed, Interface } from \"@ethersproject/abi\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = yield nameOrPromise;\n        if (typeof (name) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return getAddress(name);\n        }\n        catch (error) { }\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index) => {\n                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            overrides = shallowCopy(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = resolveProperties({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check) => __awaiter(this, void 0, void 0, function* () {\n                    if (getAddress(check.signer) !== check.override) {\n                        logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"overrides.from\"\n                        });\n                    }\n                    return check.override;\n                }));\n            }\n            else {\n                overrides.from = contract.signer.getAddress();\n            }\n        }\n        else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n            //} else {\n            // Contracts without a signer can override \"from\", and if\n            // unspecified the zero address is used\n            //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield resolveProperties({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (resolveProperties(overrides) || {})\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = accessListify(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = arrayify(data);\n            for (let i = 0; i < bytes.length; i++) {\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = shallowCopy(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(\",\")}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function (...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations) => {\n        return wait(confirmations).then((receipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event = deepCopy(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                }\n                catch (e) { }\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = () => { return contract.provider; };\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n                const overrides = shallowCopy(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({ listener: listener, once: once });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i) => i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {\n    }\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [event];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics) {\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        }\n        else {\n            filter.topics = [topic];\n        }\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        }\n        catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        }\n        catch (error) {\n            // No matching event\n        }\n    }\n}\nexport class BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        }\n        else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        defineReadOnly(this, \"callStatic\", {});\n        defineReadOnly(this, \"estimateGas\", {});\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"populateTransaction\", {});\n        defineReadOnly(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                }\n                else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        defineReadOnly(this, \"_runningEvents\", {});\n        defineReadOnly(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        }\n        else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            }\n            catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                defineReadOnly(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    defineReadOnly(this, name, this[signature]);\n                }\n            }\n            catch (e) { }\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return getContractAddress(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n            }\n            else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n        }\n        const tx = shallowCopy(overrides || {});\n        [\"from\", \"to\"].forEach(function (key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof (signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof (eventName) === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof (topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            }\n            catch (error) { }\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = deepCopy(log);\n        event.removeListener = () => {\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    }\n                    catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n        if (typeof (fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        }\n        else {\n            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n        }\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nexport class Contract extends BaseContract {\n}\nexport class ContractFactory {\n    constructor(contractInterface, bytecode, signer) {\n        let bytecodeHex = null;\n        if (typeof (bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        }\n        else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        }\n        else if (bytecode && typeof (bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        }\n        else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = getStatic(this.constructor, \"getContractAddress\")(tx);\n            const contract = getStatic(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            defineReadOnly(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return (this.constructor).getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new (this.constructor)(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n        if (typeof (compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        }\n        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return getContractAddress(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}