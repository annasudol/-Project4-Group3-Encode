{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value) {\n  const bytes = arrayify(value);\n  const padOffset = bytes.length % 32;\n\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n\n  return hexlify(bytes);\n}\n\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\n\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    }\n\n    return value;\n  };\n}\n\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n  },\n  verifyingContract: function (value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    try {\n      const bytes = arrayify(value);\n\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n\n      return hexlify(bytes);\n    } catch (error) {}\n\n    return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n  }\n};\n\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n\n      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        const v = BigNumber.from(value);\n\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n        }\n\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  } // bytesXX\n\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n\n    if (match) {\n      const width = parseInt(match[1]);\n\n      if (width === 0 || width > 32 || match[1] !== String(width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n\n      return function (value) {\n        const bytes = arrayify(value);\n\n        if (bytes.length !== width) {\n          logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n        }\n\n        return hexPadRight(value);\n      };\n    }\n  }\n\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n\n  return null;\n}\n\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(({\n    name,\n    type\n  }) => type + \" \" + name).join(\",\")})`;\n}\n\nexport class TypedDataEncoder {\n  constructor(types) {\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {}); // Link struct types to their direct child structs\n\n    const links = {}; // Link structs to structs which contain them as a child\n\n    const parents = {}; // Link all subtypes within a given struct\n\n    const subtypes = {};\n    Object.keys(types).forEach(type => {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n\n    for (const name in types) {\n      const uniqueNames = {};\n      types[name].forEach(field => {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n        }\n\n        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)\n\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n\n        if (baseType === name) {\n          logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n        } // Is this a base encoding type?\n\n\n        const encoder = getBaseEncoder(baseType);\n\n        if (encoder) {\n          return;\n        }\n\n        if (!parents[baseType]) {\n          logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n        } // Add linkage\n\n\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    } // Deduce the primary type\n\n\n    const primaryTypes = Object.keys(parents).filter(n => parents[n].length === 0);\n\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", types);\n    }\n\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]); // Check for circular type references\n\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n      }\n\n      found[type] = true;\n      Object.keys(links[type]).forEach(child => {\n        if (!parents[child]) {\n          return;\n        } // Recursively check children\n\n\n        checkCircular(child, found); // Mark all ancestors as having this decendant\n\n        Object.keys(found).forEach(subtype => {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n\n    checkCircular(this.primaryType, {}); // Compute each fully describe type\n\n    for (const name in subtypes) {\n      const st = Object.keys(subtypes[name]);\n      st.sort();\n      this._types[name] = encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\");\n    }\n  }\n\n  getEncoder(type) {\n    let encoder = this._encoderCache[type];\n\n    if (!encoder) {\n      encoder = this._encoderCache[type] = this._getEncoder(type);\n    }\n\n    return encoder;\n  }\n\n  _getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return encoder;\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      const subtype = match[1];\n      const subEncoder = this.getEncoder(subtype);\n      const length = parseInt(match[3]);\n      return value => {\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n\n        let result = value.map(subEncoder);\n\n        if (this._types[subtype]) {\n          result = result.map(keccak256);\n        }\n\n        return keccak256(hexConcat(result));\n      };\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      const encodedType = id(this._types[type]);\n      return value => {\n        const values = fields.map(({\n          name,\n          type\n        }) => {\n          const result = this.getEncoder(type)(value[name]);\n\n          if (this._types[type]) {\n            return keccak256(result);\n          }\n\n          return result;\n        });\n        values.unshift(encodedType);\n        return hexConcat(values);\n      };\n    }\n\n    return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n  }\n\n  encodeType(name) {\n    const result = this._types[name];\n\n    if (!result) {\n      logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    }\n\n    return result;\n  }\n\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n\n  hashStruct(name, value) {\n    return keccak256(this.encodeData(name, value));\n  }\n\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n\n      if (encoder) {\n        return callback(type, value);\n      }\n    } // Array\n\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n    if (match) {\n      const subtype = match[1];\n      const length = parseInt(match[3]);\n\n      if (length >= 0 && value.length !== length) {\n        logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n      }\n\n      return value.map(v => this._visit(subtype, v, callback));\n    } // Struct\n\n\n    const fields = this.types[type];\n\n    if (fields) {\n      return fields.reduce((accum, {\n        name,\n        type\n      }) => {\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n\n    return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n  }\n\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n\n  static hashDomain(domain) {\n    const domainFields = [];\n\n    for (const name in domain) {\n      const type = domainFieldTypes[name];\n\n      if (!type) {\n        logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      }\n\n      domainFields.push({\n        name,\n        type\n      });\n    }\n\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n\n  static encode(domain, types, value) {\n    return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n\n  static hash(domain, types, value) {\n    return keccak256(TypedDataEncoder.encode(domain, types, value));\n  } // Replaces all address types with ENS names with their looked up address\n\n\n  static resolveNames(domain, types, value, resolveName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Make a copy to isolate it from the object passed in\n      domain = shallowCopy(domain); // Look up all ENS names\n\n      const ensCache = {}; // Do we need to look up the domain's verifyingContract?\n\n      if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n        ensCache[domain.verifyingContract] = \"0x\";\n      } // We are going to use the encoder to visit all the base values\n\n\n      const encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n\n      encoder.visit(value, (type, value) => {\n        if (type === \"address\" && !isHexString(value, 20)) {\n          ensCache[value] = \"0x\";\n        }\n\n        return value;\n      }); // Lookup each name\n\n      for (const name in ensCache) {\n        ensCache[name] = yield resolveName(name);\n      } // Replace the domain verifyingContract if needed\n\n\n      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n        domain.verifyingContract = ensCache[domain.verifyingContract];\n      } // Replace all ENS names with their address\n\n\n      value = encoder.visit(value, (type, value) => {\n        if (type === \"address\" && ensCache[value]) {\n          return ensCache[value];\n        }\n\n        return value;\n      });\n      return {\n        domain,\n        value\n      };\n    });\n  }\n\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type\n\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n\n      if (value == null) {\n        return;\n      }\n\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = shallowCopy(types);\n\n    if (typesWithDomain.EIP712Domain) {\n      logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    } else {\n      typesWithDomain.EIP712Domain = domainTypes;\n    } // Validate the data structures and types\n\n\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return hexlify(arrayify(value));\n        } // uint or int\n\n\n        if (type.match(/^u?int/)) {\n          return BigNumber.from(value).toString();\n        }\n\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n\n          case \"bool\":\n            return !!value;\n\n          case \"string\":\n            if (typeof value !== \"string\") {\n              logger.throwArgumentError(`invalid string`, \"value\", value);\n            }\n\n            return value;\n        }\n\n        return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n      })\n    };\n  }\n\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","getAddress","BigNumber","arrayify","hexConcat","hexlify","hexZeroPad","isHexString","keccak256","deepCopy","defineReadOnly","shallowCopy","Logger","version","logger","id","padding","Uint8Array","fill","NegativeOne","from","Zero","One","MaxUint256","hexPadRight","bytes","padOffset","length","slice","hexTrue","toHexString","hexFalse","domainFieldTypes","name","chainId","verifyingContract","salt","domainFieldNames","checkString","key","throwArgumentError","JSON","stringify","domainChecks","toString","error","toLowerCase","Error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","encodeType","fields","map","join","TypedDataEncoder","constructor","types","Object","freeze","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","encoder","push","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","getEncoder","_encoderCache","_getEncoder","subEncoder","encodedType","values","unshift","encodeData","hashStruct","encode","hash","_visit","callback","reduce","accum","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","ensCache","getPayload","domainValues","domainTypes","typesWithDomain","message"],"sources":["/Users/annasudol/Documents/encode/Project4-Group3-Encode/frontend/node_modules/@ethersproject/hash/lib.esm/typed-data.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nexport class TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}